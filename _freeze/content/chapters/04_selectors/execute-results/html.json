{
  "hash": "27a92fea3cb386756dd4ed3e394de2e1",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Choose your column: selectors\"\nformat:\n    html:\n        toc: true\n    revealjs:\n        slide-number: true\n        toc: false\n        code-fold: false\n        code-tools: true\n\n---\n\n# Introduction\nVery often, column selection is more complex than simply passing a list of column\nnames to a transformer: it may be necessary to select all columns that have a\nspecific data type, or based on some other characteristic (presence of nulls,\ncolumn cardinality, etc.).\n\nThe skrub `selectors` implement a number of selection strategies that can be \ncombined in various ways to build complex filtering conditions that can then be \nemployed by `ApplyToCols`, `ApplyToFrame`, `SelectCols` and `DropCols`. \n\n## Skrub selectors\nSelectors are available from the `skrub.selectors` namespace:\n\n::: {#29c7407b .cell execution_count=1}\n``` {.python .cell-code}\nimport skrub.selectors as s\n```\n:::\n\n\nWe will use this example dataframe to test some of the selectors: \n\n::: {#4294429a .cell execution_count=2}\n``` {.python .cell-code}\nimport pandas as pd\nimport datetime\n\ndata = {\n    \"int\": [15, 56, 63, 12, 44],\n    \"float\": [5.2, 2.4, 6.2, 10.45, 9.0],\n    \"str1\": [\"public\", \"private\", None, \"private\", \"public\"],\n    \"str2\": [\"officer\", \"manager\", \"lawyer\", \"chef\", \"teacher\"],\n    \"bool\": [True, False, True, False, True],\n    \"cat1\": pd.Categorical([\"yes\", \"yes\", None, \"yes\", \"no\"]),\n    \"cat2\": pd.Categorical([\"20K+\", \"40K+\", \"60K+\", \"30K+\", \"50K+\"]),\n    \"datetime-col\": [\n        datetime.datetime.fromisoformat(dt)\n        for dt in [\n            \"2020-02-03T12:30:05\",\n            \"2021-03-15T00:37:15\",\n            \"2022-02-13T17:03:25\",\n            \"2023-05-22T08:45:55\",\n        ]\n    ]\n    + [None],    }\ndf = pd.DataFrame(data)\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>int</th>\n      <th>float</th>\n      <th>str1</th>\n      <th>str2</th>\n      <th>bool</th>\n      <th>cat1</th>\n      <th>cat2</th>\n      <th>datetime-col</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>15</td>\n      <td>5.20</td>\n      <td>public</td>\n      <td>officer</td>\n      <td>True</td>\n      <td>yes</td>\n      <td>20K+</td>\n      <td>2020-02-03 12:30:05</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>56</td>\n      <td>2.40</td>\n      <td>private</td>\n      <td>manager</td>\n      <td>False</td>\n      <td>yes</td>\n      <td>40K+</td>\n      <td>2021-03-15 00:37:15</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>63</td>\n      <td>6.20</td>\n      <td>None</td>\n      <td>lawyer</td>\n      <td>True</td>\n      <td>NaN</td>\n      <td>60K+</td>\n      <td>2022-02-13 17:03:25</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>12</td>\n      <td>10.45</td>\n      <td>private</td>\n      <td>chef</td>\n      <td>False</td>\n      <td>yes</td>\n      <td>30K+</td>\n      <td>2023-05-22 08:45:55</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>44</td>\n      <td>9.00</td>\n      <td>public</td>\n      <td>teacher</td>\n      <td>True</td>\n      <td>no</td>\n      <td>50K+</td>\n      <td>NaT</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nSelectors should be used in conjunction with the transformers described in the \nprevious chapter: `ApplyToCols`, `ApplyToFrame`, `SelectCols` and `DropCols`. \n\nSelectors allow to filter columns by data type:\n\n- `.float`: floating-point columns\n- `.integer`: integer columns\n- `.any_date`: date or datetime columns\n- `.boolean`: boolean columns\n- `.string`: columns with a String data type\n- `.categorical`: columns with a Categorical data type\n- `.numeric`: numeric (either integer or float) columns\n\n::: {#93d336d7 .cell execution_count=3}\n``` {.python .cell-code}\nfrom skrub import SelectCols\nstring_selector = s.string()\n\nSelectCols(cols=string_selector).fit_transform(df)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>str1</th>\n      <th>str2</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>public</td>\n      <td>officer</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>private</td>\n      <td>manager</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>None</td>\n      <td>lawyer</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>private</td>\n      <td>chef</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>public</td>\n      <td>teacher</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nAdditional conditions include:\n\n- `.all`: select all columns\n- `.cardinality_below`: select all columns with a number of unique values lower\nthan the given `threshold`\n- `.has_nulls`: select all columns that include at least one null value\n\n::: {#7af6c5ed .cell execution_count=4}\n``` {.python .cell-code}\nSelectCols(cols=s.has_nulls()).fit_transform(df)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>str1</th>\n      <th>cat1</th>\n      <th>datetime-col</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>public</td>\n      <td>yes</td>\n      <td>2020-02-03 12:30:05</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>private</td>\n      <td>yes</td>\n      <td>2021-03-15 00:37:15</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>None</td>\n      <td>NaN</td>\n      <td>2022-02-13 17:03:25</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>private</td>\n      <td>yes</td>\n      <td>2023-05-22 08:45:55</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>public</td>\n      <td>no</td>\n      <td>NaT</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nVarious selectors allow to choose columns based on their name: \n\n- `.cols`: choose the provided column name (or list of names)\n    - note that transformers that can accept selectors can also take column names\n    or lists of columns by default\n- `.glob`: use Unix shell style `glob` to select column names\n- `.regex`: select columns using regular expressions\n\n::: {#4088682f .cell execution_count=5}\n``` {.python .cell-code}\nSelectCols(cols=s.glob(\"cat*\")).fit_transform(df)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>cat1</th>\n      <th>cat2</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>yes</td>\n      <td>20K+</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>yes</td>\n      <td>40K+</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>NaN</td>\n      <td>60K+</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>yes</td>\n      <td>30K+</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>no</td>\n      <td>50K+</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Combining selectors\n\nSelectors can be inverted using `.inv` or the logical operator `~` to\nselect all _other_ columns, and they can be combined using the `&` and `|`\nlogical operators. It is also possible to remove from a selection with `-`; \nfor example to select all columns except for \"datetime-col\", one would write:\n\n::: {#7a121e71 .cell execution_count=6}\n``` {.python .cell-code}\nSelectCols(cols=s.all() - \"datetime-col\").fit_transform(df)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>int</th>\n      <th>float</th>\n      <th>str1</th>\n      <th>str2</th>\n      <th>bool</th>\n      <th>cat1</th>\n      <th>cat2</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>15</td>\n      <td>5.20</td>\n      <td>public</td>\n      <td>officer</td>\n      <td>True</td>\n      <td>yes</td>\n      <td>20K+</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>56</td>\n      <td>2.40</td>\n      <td>private</td>\n      <td>manager</td>\n      <td>False</td>\n      <td>yes</td>\n      <td>40K+</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>63</td>\n      <td>6.20</td>\n      <td>None</td>\n      <td>lawyer</td>\n      <td>True</td>\n      <td>NaN</td>\n      <td>60K+</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>12</td>\n      <td>10.45</td>\n      <td>private</td>\n      <td>chef</td>\n      <td>False</td>\n      <td>yes</td>\n      <td>30K+</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>44</td>\n      <td>9.00</td>\n      <td>public</td>\n      <td>teacher</td>\n      <td>True</td>\n      <td>no</td>\n      <td>50K+</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nTo select all datetime columns OR all string columns that do not contain nulls, \nwe can do:\n\n::: {#0e7e3a2a .cell execution_count=7}\n``` {.python .cell-code}\nSelectCols(cols=(s.any_date() | (s.string()) & (~s.has_nulls()))).fit_transform(df)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>str2</th>\n      <th>datetime-col</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>officer</td>\n      <td>2020-02-03 12:30:05</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>manager</td>\n      <td>2021-03-15 00:37:15</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>lawyer</td>\n      <td>2022-02-13 17:03:25</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>chef</td>\n      <td>2023-05-22 08:45:55</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>teacher</td>\n      <td>NaT</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Extracting selected columns\nSelectors can use the `expand` and `expand_index` methods to extract the columns\nthat have been selected:\n\n::: {#0ef0cfd4 .cell execution_count=8}\n``` {.python .cell-code}\nhas_nulls = s.has_nulls()\nhas_nulls.expand(df)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n['str1', 'cat1', 'datetime-col']\n```\n:::\n:::\n\n\nThis can be used, for example, to pass a list of columns to a dataframe library. \n\n::: {#4619bd86 .cell execution_count=9}\n``` {.python .cell-code}\ndf.drop(columns=has_nulls.expand(df))\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>int</th>\n      <th>float</th>\n      <th>str2</th>\n      <th>bool</th>\n      <th>cat2</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>15</td>\n      <td>5.20</td>\n      <td>officer</td>\n      <td>True</td>\n      <td>20K+</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>56</td>\n      <td>2.40</td>\n      <td>manager</td>\n      <td>False</td>\n      <td>40K+</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>63</td>\n      <td>6.20</td>\n      <td>lawyer</td>\n      <td>True</td>\n      <td>60K+</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>12</td>\n      <td>10.45</td>\n      <td>chef</td>\n      <td>False</td>\n      <td>30K+</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>44</td>\n      <td>9.00</td>\n      <td>teacher</td>\n      <td>True</td>\n      <td>50K+</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Designing custom filters\nFinally, it is possible to define function-based selectors using `.filter` and \n`.filter_names`. \n\n`.filter` selects columns for which the `predicate` evaluated by a user-defined\nfunction on the given column is `True`. It is also possible to pass arguments to\nthe function to further tweak the conditions. \nFor example, it is possible to select columns that include a certain amount of \nnulls by defining a function like the following:\n\n::: {#dc600f70 .cell execution_count=10}\n``` {.python .cell-code}\nimport pandas as pd\nimport skrub.selectors as s\nfrom skrub import DropCols\n\ndf = pd.DataFrame({\"a\": [None, None, None, 1], \"b\": [1,2,3,4]})\n\ndef more_nulls_than(col, threshold=.5):\n    return col.isnull().sum()/len(col) > threshold\n\nDropCols(cols=s.filter(more_nulls_than, threshold=0.5)).fit_transform(df)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>b</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n`.filter_names` is similar to `.filter` in the sense that it takes a function that\nreturns a predicate, but in this case the function is evaluated over the column\nnames. \n\nIf we define this example dataframe:\n\n::: {#d595f435 .cell execution_count=11}\n``` {.python .cell-code}\nfrom skrub import selectors as s\nimport pandas as pd\ndf = pd.DataFrame(\n    {\n        \"height_mm\": [297.0, 420.0],\n        \"width_mm\": [210.0, 297.0],\n        \"kind\": [\"A4\", \"A3\"],\n        \"ID\": [4, 3],\n    }\n)\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>height_mm</th>\n      <th>width_mm</th>\n      <th>kind</th>\n      <th>ID</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>297.0</td>\n      <td>210.0</td>\n      <td>A4</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>420.0</td>\n      <td>297.0</td>\n      <td>A3</td>\n      <td>3</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWe can select all the columns that end with `\"_mm\"` as follows: \n\n::: {#0d780eff .cell execution_count=12}\n``` {.python .cell-code}\nselector = s.filter_names(lambda name: name.endswith('_mm'))\ns.select(df, selector)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>height_mm</th>\n      <th>width_mm</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>297.0</td>\n      <td>210.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>420.0</td>\n      <td>297.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Conclusion\nIn this chapter we covered the skrub selectors, how they allow to select specific\ncolumns either through simple conditions, or by combining different selectors. \nMore use cases of `ApplyToCols` and the selectors will be shown through the rest\nof the course, starting from the next chapter on feature engineering.\n\n\n# Exercise: using selectors together with `ApplyToCols`\n\n**Path to the exercise**: `content/exercises/04_selectors.ipynb`\n\nConsider this example dataframe:\n\n::: {#6586d378 .cell execution_count=13}\n``` {.python .cell-code}\nimport pandas as pd\n\ndf = pd.DataFrame(\n    {\n        \"metric_1\": [10.5, 20.3, 30.1, 40.2],\n        \"metric_2\": [5.1, 15.6, None, 35.8],\n        \"metric_3\": [1.1, 3.3, 2.6, .8],\n        \"num_id\": [101, 102, 103, 104],\n        \"str_id\": [\"A101\", \"A102\", \"A103\", \"A104\"],\n        \"description\": [\"apple\", None, \"cherry\", \"date\"],\n        \"name\": [\"Alice\", \"Bob\", \"Charlie\", \"David\"],\n    }\n)\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>metric_1</th>\n      <th>metric_2</th>\n      <th>metric_3</th>\n      <th>num_id</th>\n      <th>str_id</th>\n      <th>description</th>\n      <th>name</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>10.5</td>\n      <td>5.1</td>\n      <td>1.1</td>\n      <td>101</td>\n      <td>A101</td>\n      <td>apple</td>\n      <td>Alice</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>20.3</td>\n      <td>15.6</td>\n      <td>3.3</td>\n      <td>102</td>\n      <td>A102</td>\n      <td>None</td>\n      <td>Bob</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>30.1</td>\n      <td>NaN</td>\n      <td>2.6</td>\n      <td>103</td>\n      <td>A103</td>\n      <td>cherry</td>\n      <td>Charlie</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>40.2</td>\n      <td>35.8</td>\n      <td>0.8</td>\n      <td>104</td>\n      <td>A104</td>\n      <td>date</td>\n      <td>David</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nUsing the skrub selectors and `ApplyToCols`:\n\n- Apply the `StandardScaler` to numeric columns, except `\"num_id\"`. \n- Apply a `OneHotEncoder` with `sparse_output=False` on all string columns except\n`\"str_id\"`. \n\n::: {#95847612 .cell execution_count=14}\n``` {.python .cell-code}\nimport skrub.selectors as s\nfrom sklearn.preprocessing import StandardScaler, OneHotEncoder\nfrom skrub import ApplyToCols\nfrom sklearn.pipeline import make_pipeline\n\n# Write your solution here\n# \n# \n# \n# \n# \n# \n# \n# \n# \n```\n:::\n\n\n::: {#83b6e09c .cell execution_count=15}\n``` {.python .cell-code}\nimport skrub.selectors as s\nfrom sklearn.preprocessing import StandardScaler, OneHotEncoder\nfrom skrub import ApplyToCols\nfrom sklearn.pipeline import make_pipeline\n\nscaler = ApplyToCols(StandardScaler(), cols=s.numeric() - \"num_id\")\none_hot = ApplyToCols(OneHotEncoder(sparse_output=False), cols=s.string() - \"str_id\")\n\ntransformer = make_pipeline(scaler, one_hot)\n\ntransformer.fit_transform(df)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>metric_1</th>\n      <th>metric_2</th>\n      <th>metric_3</th>\n      <th>num_id</th>\n      <th>str_id</th>\n      <th>description_apple</th>\n      <th>description_cherry</th>\n      <th>description_date</th>\n      <th>description_None</th>\n      <th>name_Alice</th>\n      <th>name_Bob</th>\n      <th>name_Charlie</th>\n      <th>name_David</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>-1.336178</td>\n      <td>-1.077965</td>\n      <td>-0.820768</td>\n      <td>101</td>\n      <td>A101</td>\n      <td>1.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>-0.449914</td>\n      <td>-0.253793</td>\n      <td>1.303572</td>\n      <td>102</td>\n      <td>A102</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>0.436349</td>\n      <td>NaN</td>\n      <td>0.627646</td>\n      <td>103</td>\n      <td>A103</td>\n      <td>0.0</td>\n      <td>1.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>1.349743</td>\n      <td>1.331758</td>\n      <td>-1.110450</td>\n      <td>104</td>\n      <td>A104</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nGiven the same dataframe and using selectors, drop only string columns that contain\nnulls. \n\n::: {#436ac455 .cell execution_count=16}\n``` {.python .cell-code}\nfrom skrub import DropCols\n\n# Write your solution here\n# \n# \n# \n# \n# \n# \n# \n```\n:::\n\n\n::: {#35326a3d .cell execution_count=17}\n``` {.python .cell-code}\nfrom skrub import DropCols\n\nDropCols(cols=s.has_nulls() & s.string()).fit_transform(df)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>metric_1</th>\n      <th>metric_2</th>\n      <th>metric_3</th>\n      <th>num_id</th>\n      <th>str_id</th>\n      <th>name</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>10.5</td>\n      <td>5.1</td>\n      <td>1.1</td>\n      <td>101</td>\n      <td>A101</td>\n      <td>Alice</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>20.3</td>\n      <td>15.6</td>\n      <td>3.3</td>\n      <td>102</td>\n      <td>A102</td>\n      <td>Bob</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>30.1</td>\n      <td>NaN</td>\n      <td>2.6</td>\n      <td>103</td>\n      <td>A103</td>\n      <td>Charlie</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>40.2</td>\n      <td>35.8</td>\n      <td>0.8</td>\n      <td>104</td>\n      <td>A104</td>\n      <td>David</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nNow write a custom function that selects columns where all values are lower than\n`10.0`. \n\n::: {#326d9362 .cell execution_count=18}\n``` {.python .cell-code}\nfrom skrub import SelectCols\n\n# Write your solution here\n# \n# \n# \n# \n# \n# \n# \n```\n:::\n\n\n::: {#2c3e74d5 .cell execution_count=19}\n``` {.python .cell-code}\nfrom skrub import SelectCols\n\ndef lower_than(col):\n    return all(col < 10.0)\n\nSelectCols(cols=s.numeric() & s.filter(lower_than)).fit_transform(df)\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>metric_3</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1.1</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>3.3</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2.6</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>0.8</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n",
    "supporting": [
      "04_selectors_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js\" integrity=\"sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js\" integrity=\"sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}