{
  "hash": "692a4f510e9029414f694510da1ffbbf",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Applying transformers to columns\"\nformat:\n    revealjs:\n        slide-number: true\n        toc: true\n        code-fold: false\n        code-tools: true\n\n---\n\n## Introduction\nOften, transformers need to be applied only to a subset of columns, rather than \nthe entire dataframe. \n\nAs an example, it does not make sense to apply a `StandardScaler` to a column \nthat contains strings, and indeed doing so would raise an exception. \n\nScikit-learn provides the `ColumnTransformer` to deal with this: \n\n::: {#b6136656 .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nfrom sklearn.compose import make_column_selector as selector\nfrom sklearn.compose import make_column_transformer\nfrom sklearn.preprocessing import StandardScaler, OneHotEncoder\n\ndf = pd.DataFrame({\"text\": [\"foo\", \"bar\", \"baz\"], \"number\": [1, 2, 3]})\n\ncategorical_columns = selector(dtype_include=object)(df)\nnumerical_columns = selector(dtype_exclude=object)(df)\n\nct = make_column_transformer(\n      (StandardScaler(),\n       numerical_columns),\n      (OneHotEncoder(handle_unknown=\"ignore\"),\n       categorical_columns))\ntransformed = ct.fit_transform(df)\ntransformed\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\narray([[-1.22474487,  0.        ,  0.        ,  1.        ],\n       [ 0.        ,  1.        ,  0.        ,  0.        ],\n       [ 1.22474487,  0.        ,  1.        ,  0.        ]])\n```\n:::\n:::\n\n\n`make_column_selector` allows to choose columns based on their datatype, or by \nusing regex to filter column names. In some cases, this degree of control is \nnot sufficient. \n\nTo address such situations, skrub implements different transformers that allow \nto modify columns from within scikit-learn pipelines. Additionally, the selectors\nAPI allows to implement powerful, custom-made column selection filters. \n\n`SelectCols` and `DropCols` are transformers that can be used as part of a \npipeline to filter columns according to the selectors API, while `ApplyToCols` and\n`ApplyToFrame` replicate the `ColumnTransformer` behavior with a different syntax\nand access to the selectors. \n\n## `ApplyToCols` and `ApplyToFrame`\n\n### Applying a transformer to separate columns: `ApplyToCols`\nIn many cases, `ApplyToCols` can be a direct replacememnt for the `ColumnTransformer`,\nlike in the following example:\n\n::: {#137501d7 .cell execution_count=2}\n``` {.python .cell-code}\nimport skrub.selectors as s\nfrom sklearn.pipeline import make_pipeline\nfrom skrub import ApplyToCols\n\nnumeric = ApplyToCols(StandardScaler(), cols=s.numeric())\nstring = ApplyToCols(OneHotEncoder(sparse_output=False), cols=s.string())\n\ntransformed = make_pipeline(numeric, string).fit_transform(df)\ntransformed\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>text_bar</th>\n      <th>text_baz</th>\n      <th>text_foo</th>\n      <th>number</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n      <td>-1.224745</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>1.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.000000</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>0.0</td>\n      <td>1.0</td>\n      <td>0.0</td>\n      <td>1.224745</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nIn this case, we are applying the `StandardScaler` only to numeric features using \n`s.numeric()`, and `OneHotEncoder` with `s.string()`. \n\nUnder the hood, `ApplyToCol` selects all columns that satisfy the condition specified\nin `cols` (in this case, that the dtype is numeric), then clones and applies the\nspecified transformer (`StandardScaler`) to each column _separately_. \n\n::: {.callout-important}\nColumns that are not selected are passed through without any change, thus string\ncolumns are not touched by the `numeric` transformer. \n:::\n\nBy passing through unselected columns without changes it is possible to chain \nseveral `ApplyToCols` together by putting them in a scikit-learn pipeline. \n\n### Applying the same transformer to multiple columns at once: `ApplyToFrame`\nIn some cases, it may be beneficial to apply the same transformer to a subset of \ncolumns in a dataframe. \n\nThis example dataframe contains some patient information, and some (random) \nmetrics. \n\n::: {#59cb8c8a .cell execution_count=3}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\n\nn_patients = 20\nnp.random.seed(42)\ndf = pd.DataFrame({\n    \"patient_id\": [f\"P{i:03d}\" for i in range(n_patients)],\n    \"age\": np.random.randint(18, 80, size=n_patients),\n    \"sex\": np.random.choice([\"M\", \"F\"], size=n_patients),\n})\n\nfor i in range(5):\n    df[f\"metric_{i}\"] = np.random.normal(loc=50, scale=10, size=n_patients)\n\ndf[\"diagnosis\"] = np.random.choice([\"A\", \"B\", \"C\"], size=n_patients)\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>patient_id</th>\n      <th>age</th>\n      <th>sex</th>\n      <th>metric_0</th>\n      <th>metric_1</th>\n      <th>metric_2</th>\n      <th>metric_3</th>\n      <th>metric_4</th>\n      <th>diagnosis</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>P000</td>\n      <td>56</td>\n      <td>F</td>\n      <td>39.871689</td>\n      <td>52.088636</td>\n      <td>41.607825</td>\n      <td>50.870471</td>\n      <td>52.961203</td>\n      <td>B</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>P001</td>\n      <td>69</td>\n      <td>M</td>\n      <td>53.142473</td>\n      <td>30.403299</td>\n      <td>46.907876</td>\n      <td>47.009926</td>\n      <td>52.610553</td>\n      <td>A</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>P002</td>\n      <td>46</td>\n      <td>F</td>\n      <td>40.919759</td>\n      <td>36.718140</td>\n      <td>53.312634</td>\n      <td>50.917608</td>\n      <td>50.051135</td>\n      <td>B</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>P003</td>\n      <td>32</td>\n      <td>F</td>\n      <td>35.876963</td>\n      <td>51.968612</td>\n      <td>59.755451</td>\n      <td>30.124311</td>\n      <td>47.654129</td>\n      <td>B</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>P004</td>\n      <td>60</td>\n      <td>F</td>\n      <td>64.656488</td>\n      <td>57.384666</td>\n      <td>45.208258</td>\n      <td>47.803281</td>\n      <td>35.846293</td>\n      <td>C</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWith `ApplyToFrame`, it is easy to apply a decomposition algorithm such as `PCA` \nto condense the `metric_*` columns into a smaller number of features: \n\n::: {#ae7520a3 .cell execution_count=4}\n``` {.python .cell-code}\nfrom skrub import ApplyToFrame\nfrom sklearn.decomposition import PCA\n\nreduce = ApplyToFrame(PCA(n_components=2), cols=s.glob(\"metric_*\"))\n\ndf_reduced = reduce.fit_transform(df)\ndf_reduced.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>patient_id</th>\n      <th>age</th>\n      <th>sex</th>\n      <th>diagnosis</th>\n      <th>pca0</th>\n      <th>pca1</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>P000</td>\n      <td>56</td>\n      <td>F</td>\n      <td>B</td>\n      <td>-2.647377</td>\n      <td>7.025046</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>P001</td>\n      <td>69</td>\n      <td>M</td>\n      <td>A</td>\n      <td>-2.480564</td>\n      <td>-11.246997</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>P002</td>\n      <td>46</td>\n      <td>F</td>\n      <td>B</td>\n      <td>4.274840</td>\n      <td>-5.039065</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>P003</td>\n      <td>32</td>\n      <td>F</td>\n      <td>B</td>\n      <td>14.116747</td>\n      <td>15.620615</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>P004</td>\n      <td>60</td>\n      <td>F</td>\n      <td>C</td>\n      <td>-19.073862</td>\n      <td>1.186541</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Selection operations in a scikit-learn pipeline\nIn some situations, it may be necessary to select or remove specific columns from\na dataframe: unlike `ApplyToCols` and `ApplyToFrame`, this means removing some \nfeatures from the original table. This can be done with `SelectCols` and `DropCols`, \nwhich work as their name suggests, and can take a `cols` parameter to choose\nwhich columns to select or drop respectively.\n\n## Exercise: putting everything together in a scikit-learn pipeline\n\n",
    "supporting": [
      "03_feat_eng_apply_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js\" integrity=\"sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js\" integrity=\"sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}