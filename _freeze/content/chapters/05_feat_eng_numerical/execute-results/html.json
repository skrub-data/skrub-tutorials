{
  "hash": "1b175409adaed0cdd0ba37bd44757820",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Scaling numerical features safely\"\nformat:\n    revealjs:\n        slide-number: true\n        toc: true\n        code-fold: false\n        code-tools: true\n\n---\n\n## Introduction \nNow that we can transform any column we want thanks to `ApplyToCols`, `ApplyToFrame` \nand the selectors, we can start covering the feature engineering part of our \npipeline, beginning from numerical features. \n\nSpecifically, we will find out how to safely scale numerical features with the \nskrub `SquashingScaler`.\n\n## Numerical features with outliers\n\nWhen dealing with numerical features that contain outliers (including infinite\nvalues), standard scaling methods can be problematic. Outliers can dramatically\naffect the centering and scaling of the entire dataset, causing the scaled inliers\nto be compressed into a narrow range.\n\nConsider this example:\n\n::: {#cd0e321f .cell execution_count=1}\n``` {.python .cell-code}\nfrom helpers import (\n    generate_data_with_outliers,\n    plot_feature_with_outliers\n)\n\nvalues = generate_data_with_outliers()\n\nplot_feature_with_outliers(values)\n```\n\n::: {.cell-output .cell-output-display}\n![](05_feat_eng_numerical_files/figure-html/cell-2-output-1.png){width=587 height=395}\n:::\n:::\n\n\nIn this case, most of the values are in the range `[-2, 2]`, but there are some \nlarge outliers in the range `[-40, 40]` that can cause issues when the feature \nneeds to be scaled. \n\n\n### Regular scalers and their limitations\n\nThe **StandardScaler** computes mean and standard deviation across all values.\nWith outliers present, these statistics become unreliable, and the scaling factor\ncan become too small, squashing inlier values.\n\nThe **RobustScaler** uses quantiles (typically the 25th and 75th percentiles)\ninstead of mean/std, which makes it more resistant to outliers. However, it\ndoesn't bound the output values, so extreme outliers can still have very large\nscaled values.\n\n## SquashingScaler: A robust solution\n\nThe `SquashingScaler` combines robust centering with smooth clipping to handle\noutliers effectively. It works in two stages:\n\n### Stage 1: Robust Scaling\n- Centers the median to zero\n- Scales using quantile-based statistics (by default, the interquartile range)\n- For columns where quantiles are equal, uses a custom MinMaxScaler\n- For columns with constant values, fills with zeros\n\n### Stage 2: Soft Clipping\n- Applies a smooth squashing function:\n$x_{\\text{out}} = \\frac{z}{\\sqrt{1 + (z/B)^2}}$\n- Constrains all values to the range\n$[-\\texttt{max\\_absolute\\_value}, \\texttt{max\\_absolute\\_value}]$ (default: 3)\n- Maps infinite values to the corresponding boundaries\n- Preserves NaN values unchanged\n\n### Advantages and disadvantages of `SquashingScaler`\nThe `SquashingScaler` has various advantages over traditional scalers: \n\n- It is **Outlier-resistant**: Outliers don't affect inlier scaling, unlike the\n`StandardScaler`.\n- It has **Bounded output**: All values stay in a predictable range, ideal for \nneural networks and linear models.\n- It **Handles edge cases**: The scaler works with infinite values and constant \ncolumns.\n- It **Preserves missing data**: NaN values are kept unchanged. \n\nA disadvantage of the `SquashingScaler` is that it is**Non-invertible**: \nThe soft clipping function is smooth but cannot be exactly inverted. \n\n## Conclusion\n\nWhen compared on data with outliers:\n\n- **StandardScaler** compresses inliers due to large scaling factors\n- **RobustScaler** preserves relative scales but allows extreme outlier values\n- **SquashingScaler** keeps inliers in a reasonable range while smoothly bounding\nall values\n\nIf we plot the impact of each scaler on the result, this is what we can see: \n\n::: {#8d3e40cf .cell execution_count=2}\n``` {.python .cell-code}\nfrom helpers import scale_feature_and_plot\nscale_feature_and_plot(values)\n```\n\n::: {.cell-output .cell-output-display}\n![](05_feat_eng_numerical_files/figure-html/cell-3-output-1.png){width=815 height=491}\n:::\n:::\n\n\nIn this section we showed how the `SquashingScaler` can be a better answer than\ntraditional scalers when a numeric feature includes outliers. \n\n",
    "supporting": [
      "05_feat_eng_numerical_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}