{
  "hash": "5ec58a0b2bf820a61e81ca0c62365f23",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Encoding datetime features with `DatetimeEncoder`\"\nformat:\n    revealjs:\n        slide-number: true\n        toc: true\n        code-fold: false\n        code-tools: true\n\n---\n\n1. With pandas/polars\n2. Specifying the datetime format\n3. DatetimeEncoder default \n4. DatetimeEncoder additional parameters\n5. Periodic encoders\n\n## Introduction to Datetime Features\n\nDatetime features are very important for many data analysis and machine learning \ntasks, as they often carry significant information about temporal patterns and \ntrends. For instance, including as features the day of the week, time of day, or \nseason can provide valuable insights for predictive modeling.\n\nHowever, working with datetime data can be difficult due to the variety of formats\nin which dates and times are represented. Typical formats include `\"%Y-%m-%d\"`, `\"%d/%m/%Y\"`, \nand `\"%d %B %Y\"`, among others. Parsing these formats correctly is essential to \navoid errors and ensure accurate feature extraction. \n\nIn this section we are going to cover how skrub can help with dealing with \ndatetimes using `to_datetime`, `ToDatetime`, and the `DatetimeEncoder`. \n\n## Converting datetime strings to datetime objects\nOften, the first operation that must be done to work with datetime objects is \nconverting the datetimes from a string representation to a proper datetime object.\nThis is beneficial because using datetimes gives access to datetime-specific \nfeatures, and allows to access the different parts of the datetime. \n\nSkrub provides different objects to deal with the conversion problem.\n\n**`ToDatetime`** is a single column transformer that tries to conver the given\ncolumn to datetime either by relying on a user-provided format, or by guessing\ncommon formats. Since this transformer must be applied to single columns (rather\nthan dataframes), it is typically better to use it in conjunction with `ApplyToCols`. \nAdditionally, the `allow_reject` parameter of `ApplyToCols` should be set to `True` \nto avoid raising exceptions for non-datetime columns:\n\n::: {#777e6a91 .cell execution_count=1}\n``` {.python .cell-code}\nfrom skrub import ApplyToCols, ToDatetime\n\nimport pandas as pd\n\ndata = {\n    \"dates\": [\n        \"2023-01-03\",\n        \"2023-02-15\",\n        \"2023-03-27\",\n        \"2023-04-10\",\n    ]\n}\ndf = pd.DataFrame(data)\n\ndf_enc = ApplyToCols(ToDatetime(), allow_reject=True).fit_transform(df)\n```\n:::\n\n\n**`to_datetime`** works similarly to \n[pd.to_datetime](https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html#pandas.to_datetime), \nor the example shown above with `ApplyToCols`. \n\n::: {.callout-warning}\n`to_datetime` is a stateless function, so it should not be used in a pipeline, because\nit does not guarantee consistency between `fit_transform` and successive `transform`. \n`ApplyToCols(ToDatetime(), allow_reject=True)` is a better solution for pipelines. \n:::\n\nFinally, the standard `Cleaner` can be used for parsing datetimes, as it uses\n`ToDatetime` under the hood, and can take the `datetime_format`. As the `Cleaner`\nis a transformer, it guarantees consistency between `fit_transform` and `transform`. \n\n## Encoding datetime features\nDatetimes cannot be used \"as-is\" for training ML models, and must instead be \nconverted to numerical features. Typically, this is done by \"splitting\" the \ndatetime parts (year, month, day etc.) into separate columns, so that each column\ncontains only one number. \n\nAdditional features may also be of interest, such as the number of seconds since \nepoch (which increases monotonically and gives an indication of the order of entries), \nwhether a date is a weekday or weekend, or the day of the year. \n\nTo achieve this with standard dataframe libraries, the code looks like this: \n\n::: {#acac5969 .cell execution_count=2}\n``` {.python .cell-code}\ndf_enc[\"year\"] = df_enc[\"dates\"].dt.year\ndf_enc[\"month\"] = df_enc[\"dates\"].dt.month\ndf_enc[\"day\"] = df_enc[\"dates\"].dt.day\ndf_enc[\"weekday\"] = df_enc[\"dates\"].dt.weekday\ndf_enc[\"day_of_year\"] = df_enc[\"dates\"].dt.day_of_year\ndf_enc[\"total_seconds\"] = (df_enc[\"dates\"] - pd.Timestamp(\"1970-01-01\")) // pd.Timedelta(seconds=1)\n\ndf_enc\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>dates</th>\n      <th>year</th>\n      <th>month</th>\n      <th>day</th>\n      <th>weekday</th>\n      <th>day_of_year</th>\n      <th>total_seconds</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2023-01-03</td>\n      <td>2023</td>\n      <td>1</td>\n      <td>3</td>\n      <td>1</td>\n      <td>3</td>\n      <td>1672704000</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2023-02-15</td>\n      <td>2023</td>\n      <td>2</td>\n      <td>15</td>\n      <td>2</td>\n      <td>46</td>\n      <td>1676419200</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2023-03-27</td>\n      <td>2023</td>\n      <td>3</td>\n      <td>27</td>\n      <td>0</td>\n      <td>86</td>\n      <td>1679875200</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>2023-04-10</td>\n      <td>2023</td>\n      <td>4</td>\n      <td>10</td>\n      <td>0</td>\n      <td>100</td>\n      <td>1681084800</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nSkrub's `DatetimeEncoder` allows to add the same features with a simpler interface.\nAs the `DatetimeEncoder` is a single column transformer, we use again `ApplyToCols`. \n\n::: {#c1078b28 .cell execution_count=3}\n``` {.python .cell-code}\nfrom skrub import DatetimeEncoder\n\ndf_enc = ApplyToCols(ToDatetime(), allow_reject=True).fit_transform(df)\n\nde = DatetimeEncoder(add_total_seconds=True, add_weekday=True, add_day_of_year=True)\n\ndf_enc = ApplyToCols(de, cols=\"dates\").fit_transform(df_enc)\ndf_enc\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>dates_year</th>\n      <th>dates_month</th>\n      <th>dates_day</th>\n      <th>dates_total_seconds</th>\n      <th>dates_weekday</th>\n      <th>dates_day_of_year</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2023.0</td>\n      <td>1.0</td>\n      <td>3.0</td>\n      <td>1.672704e+09</td>\n      <td>2.0</td>\n      <td>3.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2023.0</td>\n      <td>2.0</td>\n      <td>15.0</td>\n      <td>1.676419e+09</td>\n      <td>3.0</td>\n      <td>46.0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2023.0</td>\n      <td>3.0</td>\n      <td>27.0</td>\n      <td>1.679875e+09</td>\n      <td>1.0</td>\n      <td>86.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>2023.0</td>\n      <td>4.0</td>\n      <td>10.0</td>\n      <td>1.681085e+09</td>\n      <td>1.0</td>\n      <td>100.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Periodic features\nPeriodic features are useful for training machine learning models because they\ncapture the cyclical nature of certain data patterns. For example, time-related\nfeatures such as hours in a day, days in a week, or months in a year often exhibit\nperiodic behavior. By encoding these features periodically, models can better\nunderstand and predict patterns that repeat over time, such as daily traffic\ntrends, weekly sales cycles, or seasonal variations. This ensures that the model\ntreats the start and end of a cycle as close neighbors, improving its ability to\ngeneralize and make accurate predictions.\n\nThis can be done manually with dataframe libraries. For example, circular encoding\n(a.k.a., trigonometric or sin/cos encoding) can be implemented with Pandas like so:\n\n::: {#1ef589d5 .cell execution_count=4}\n``` {.python .cell-code}\nimport numpy as np \n\ndf_enc = ApplyToCols(ToDatetime(), allow_reject=True).fit_transform(df)\n\ndf_enc[\"day_of_year\"] = df_enc[\"dates\"].dt.day_of_year\ndf_enc[\"day_of_year_sin\"] = np.sin(2 * np.pi * df_enc[\"day_of_year\"] / 365)\ndf_enc[\"day_of_year_cos\"] = np.cos(2 * np.pi * df_enc[\"day_of_year\"] / 365)\n\ndf_enc[\"weekday\"] = df_enc[\"dates\"].dt.weekday\ndf_enc[\"weekday_sin\"] = np.sin(2 * np.pi * df_enc[\"weekday\"] / 7)\ndf_enc[\"weekday_cos\"] = np.cos(2 * np.pi * df_enc[\"weekday\"] / 7)\n\ndf_enc\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>dates</th>\n      <th>day_of_year</th>\n      <th>day_of_year_sin</th>\n      <th>day_of_year_cos</th>\n      <th>weekday</th>\n      <th>weekday_sin</th>\n      <th>weekday_cos</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2023-01-03</td>\n      <td>3</td>\n      <td>0.051620</td>\n      <td>0.998667</td>\n      <td>1</td>\n      <td>0.781831</td>\n      <td>0.623490</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2023-02-15</td>\n      <td>46</td>\n      <td>0.711657</td>\n      <td>0.702527</td>\n      <td>2</td>\n      <td>0.974928</td>\n      <td>-0.222521</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2023-03-27</td>\n      <td>86</td>\n      <td>0.995919</td>\n      <td>0.090252</td>\n      <td>0</td>\n      <td>0.000000</td>\n      <td>1.000000</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>2023-04-10</td>\n      <td>100</td>\n      <td>0.988678</td>\n      <td>-0.150055</td>\n      <td>0</td>\n      <td>0.000000</td>\n      <td>1.000000</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nAlternatively, the `DatetimeEncoder` can add periodic features using either circular\nor spline encoding through the `periodic_encoding` parameter:\n\n::: {#f5ee9fd6 .cell execution_count=5}\n``` {.python .cell-code}\nde = DatetimeEncoder(periodic_encoding=\"circular\")\n\ndf_enc = ApplyToCols(de, cols=\"dates\").fit_transform(df_enc)\ndf_enc\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>dates_year</th>\n      <th>dates_total_seconds</th>\n      <th>dates_month_circular_0</th>\n      <th>dates_month_circular_1</th>\n      <th>dates_day_circular_0</th>\n      <th>dates_day_circular_1</th>\n      <th>day_of_year</th>\n      <th>day_of_year_sin</th>\n      <th>day_of_year_cos</th>\n      <th>weekday</th>\n      <th>weekday_sin</th>\n      <th>weekday_cos</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2023.0</td>\n      <td>1.672704e+09</td>\n      <td>0.500000</td>\n      <td>8.660254e-01</td>\n      <td>5.877853e-01</td>\n      <td>0.809017</td>\n      <td>3</td>\n      <td>0.051620</td>\n      <td>0.998667</td>\n      <td>1</td>\n      <td>0.781831</td>\n      <td>0.623490</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2023.0</td>\n      <td>1.676419e+09</td>\n      <td>0.866025</td>\n      <td>5.000000e-01</td>\n      <td>1.224647e-16</td>\n      <td>-1.000000</td>\n      <td>46</td>\n      <td>0.711657</td>\n      <td>0.702527</td>\n      <td>2</td>\n      <td>0.974928</td>\n      <td>-0.222521</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2023.0</td>\n      <td>1.679875e+09</td>\n      <td>1.000000</td>\n      <td>6.123234e-17</td>\n      <td>-5.877853e-01</td>\n      <td>0.809017</td>\n      <td>86</td>\n      <td>0.995919</td>\n      <td>0.090252</td>\n      <td>0</td>\n      <td>0.000000</td>\n      <td>1.000000</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>2023.0</td>\n      <td>1.681085e+09</td>\n      <td>0.866025</td>\n      <td>-5.000000e-01</td>\n      <td>8.660254e-01</td>\n      <td>-0.500000</td>\n      <td>100</td>\n      <td>0.988678</td>\n      <td>-0.150055</td>\n      <td>0</td>\n      <td>0.000000</td>\n      <td>1.000000</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Conclusions\n\nIn this chapter, we explored the importance and challenges of working with datetime\nfeatures. We covered how to convert string representations of dates to datetime\nobjects using skrub's `ToDatetime` transformer and the `Cleaner`, both of which\ncan be integrated into pipelines for robust preprocessing.\n\nWe also discussed the need to encode datetime features into numerical\nrepresentations suitable for machine learning models. The `DatetimeEncoder`\nprovides a convenient way to extract useful components such as year, month, day,\nweekday, day of year, and total seconds since epoch. Additionally, we saw how\nperiodic (circular) encoding can be used to capture cyclical patterns in\ntime-based data.\n\n## Exercise\nUse one of the methods explained so far (Cleaner/ApplyToCols) to convert the provided\ndataframe to datetime dtype, then extract the following features: \n- All parts of the datetime \n- The number of seconds from epoch\n- The day in the week\n- The day of the year\n\n**Hint**: use the format `\"%d %B %Y\"` for the datetime. \n\n::: {#7ef819b9 .cell execution_count=6}\n``` {.python .cell-code}\nimport pandas as pd\n\ndata = {\n    \"admission_dates\": [\n        \"03 January 2023\",\n        \"15 February 2023\",\n        \"27 March 2023\",\n        \"10 April 2023\",\n    ],\n    \"patient_ids\": [101, 102, 103, 104],\n    \"age\": [25, 34, 45, 52],\n    \"outcome\": [\"Recovered\", \"Under Treatment\", \"Recovered\", \"Deceased\"],\n}\ndf = pd.DataFrame(data)\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    admission_dates  patient_ids  age          outcome\n0   03 January 2023          101   25        Recovered\n1  15 February 2023          102   34  Under Treatment\n2     27 March 2023          103   45        Recovered\n3     10 April 2023          104   52         Deceased\n```\n:::\n:::\n\n\n::: {#471c9f6e .cell execution_count=7}\n``` {.python .cell-code}\n# Write your solution here\n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n```\n:::\n\n\n::: {#3b6c2582 .cell execution_count=8}\n``` {.python .cell-code}\n# Solution with ApplyToCols and ToDatetime\nfrom skrub import ApplyToCols, ToDatetime, DatetimeEncoder\nfrom sklearn.pipeline import make_pipeline\nimport skrub.selectors as s\n\nto_datetime_encoder = ApplyToCols(ToDatetime(format=\"%d %B %Y\"), cols=\"admission_dates\")\n\ndatetime_encoder = ApplyToCols(\n    DatetimeEncoder(add_total_seconds=True, add_weekday=True, add_day_of_year=True),\n    cols=s.any_date(),\n)\n\nencoder = make_pipeline(to_datetime_encoder, datetime_encoder)\nencoder.fit_transform(df)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>admission_dates_year</th>\n      <th>admission_dates_month</th>\n      <th>admission_dates_day</th>\n      <th>admission_dates_total_seconds</th>\n      <th>admission_dates_weekday</th>\n      <th>admission_dates_day_of_year</th>\n      <th>patient_ids</th>\n      <th>age</th>\n      <th>outcome</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2023.0</td>\n      <td>1.0</td>\n      <td>3.0</td>\n      <td>1.672704e+09</td>\n      <td>2.0</td>\n      <td>3.0</td>\n      <td>101</td>\n      <td>25</td>\n      <td>Recovered</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2023.0</td>\n      <td>2.0</td>\n      <td>15.0</td>\n      <td>1.676419e+09</td>\n      <td>3.0</td>\n      <td>46.0</td>\n      <td>102</td>\n      <td>34</td>\n      <td>Under Treatment</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2023.0</td>\n      <td>3.0</td>\n      <td>27.0</td>\n      <td>1.679875e+09</td>\n      <td>1.0</td>\n      <td>86.0</td>\n      <td>103</td>\n      <td>45</td>\n      <td>Recovered</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>2023.0</td>\n      <td>4.0</td>\n      <td>10.0</td>\n      <td>1.681085e+09</td>\n      <td>1.0</td>\n      <td>100.0</td>\n      <td>104</td>\n      <td>52</td>\n      <td>Deceased</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#00070489 .cell execution_count=9}\n``` {.python .cell-code}\n# Solution with Cleaner\nfrom skrub import Cleaner\nfrom sklearn.pipeline import make_pipeline\nimport skrub.selectors as s\n\ndatetime_encoder = ApplyToCols(\n    DatetimeEncoder(add_total_seconds=True, add_weekday=True, add_day_of_year=True),\n    cols=s.any_date(),\n)\n\nencoder = make_pipeline(Cleaner(datetime_format=\"%d %B %Y\"), datetime_encoder)\nencoder.fit_transform(df)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>admission_dates_year</th>\n      <th>admission_dates_month</th>\n      <th>admission_dates_day</th>\n      <th>admission_dates_total_seconds</th>\n      <th>admission_dates_weekday</th>\n      <th>admission_dates_day_of_year</th>\n      <th>patient_ids</th>\n      <th>age</th>\n      <th>outcome</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2023.0</td>\n      <td>1.0</td>\n      <td>3.0</td>\n      <td>1.672704e+09</td>\n      <td>2.0</td>\n      <td>3.0</td>\n      <td>101</td>\n      <td>25</td>\n      <td>Recovered</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2023.0</td>\n      <td>2.0</td>\n      <td>15.0</td>\n      <td>1.676419e+09</td>\n      <td>3.0</td>\n      <td>46.0</td>\n      <td>102</td>\n      <td>34</td>\n      <td>Under Treatment</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2023.0</td>\n      <td>3.0</td>\n      <td>27.0</td>\n      <td>1.679875e+09</td>\n      <td>1.0</td>\n      <td>86.0</td>\n      <td>103</td>\n      <td>45</td>\n      <td>Recovered</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>2023.0</td>\n      <td>4.0</td>\n      <td>10.0</td>\n      <td>1.681085e+09</td>\n      <td>1.0</td>\n      <td>100.0</td>\n      <td>104</td>\n      <td>52</td>\n      <td>Deceased</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nModify the script so that the `DatetimeEncoder` adds periodic encoding with sine\nand cosine (aka circular encoding):\n\n::: {#d903e452 .cell execution_count=10}\n``` {.python .cell-code}\n# Write your solution here\n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n```\n:::\n\n\nNow modify the script above to add spline features (`periodic_encoding=\"spline\"`). \n\n::: {#f1a2ddaf .cell execution_count=11}\n``` {.python .cell-code}\n# Solution\nfrom skrub import Cleaner\nfrom sklearn.pipeline import make_pipeline\nimport skrub.selectors as s\n\ndatetime_encoder = ApplyToCols(\n    DatetimeEncoder(\n        periodic_encoding=\"spline\",\n        add_total_seconds=True,\n        add_weekday=True,\n        add_day_of_year=True,\n    ),\n    cols=s.any_date(),\n)\n\nencoder = make_pipeline(Cleaner(datetime_format=\"%d %B %Y\"), datetime_encoder)\nencoder.fit_transform(df)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>admission_dates_year</th>\n      <th>admission_dates_total_seconds</th>\n      <th>admission_dates_day_of_year</th>\n      <th>admission_dates_month_spline_00</th>\n      <th>admission_dates_month_spline_01</th>\n      <th>admission_dates_month_spline_02</th>\n      <th>admission_dates_month_spline_03</th>\n      <th>admission_dates_month_spline_04</th>\n      <th>admission_dates_month_spline_05</th>\n      <th>admission_dates_month_spline_06</th>\n      <th>...</th>\n      <th>admission_dates_weekday_spline_0</th>\n      <th>admission_dates_weekday_spline_1</th>\n      <th>admission_dates_weekday_spline_2</th>\n      <th>admission_dates_weekday_spline_3</th>\n      <th>admission_dates_weekday_spline_4</th>\n      <th>admission_dates_weekday_spline_5</th>\n      <th>admission_dates_weekday_spline_6</th>\n      <th>patient_ids</th>\n      <th>age</th>\n      <th>outcome</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2023.0</td>\n      <td>1.672704e+09</td>\n      <td>3.0</td>\n      <td>0.0</td>\n      <td>0.166667</td>\n      <td>0.666667</td>\n      <td>0.166667</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>...</td>\n      <td>0.0</td>\n      <td>0.000000</td>\n      <td>0.166667</td>\n      <td>0.666667</td>\n      <td>0.166667</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>101</td>\n      <td>25</td>\n      <td>Recovered</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2023.0</td>\n      <td>1.676419e+09</td>\n      <td>46.0</td>\n      <td>0.0</td>\n      <td>0.000000</td>\n      <td>0.166667</td>\n      <td>0.666667</td>\n      <td>0.166667</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>...</td>\n      <td>0.0</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.166667</td>\n      <td>0.666667</td>\n      <td>0.166667</td>\n      <td>0.0</td>\n      <td>102</td>\n      <td>34</td>\n      <td>Under Treatment</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2023.0</td>\n      <td>1.679875e+09</td>\n      <td>86.0</td>\n      <td>0.0</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.166667</td>\n      <td>0.666667</td>\n      <td>0.166667</td>\n      <td>0.000000</td>\n      <td>...</td>\n      <td>0.0</td>\n      <td>0.166667</td>\n      <td>0.666667</td>\n      <td>0.166667</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>103</td>\n      <td>45</td>\n      <td>Recovered</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>2023.0</td>\n      <td>1.681085e+09</td>\n      <td>100.0</td>\n      <td>0.0</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.166667</td>\n      <td>0.666667</td>\n      <td>0.166667</td>\n      <td>...</td>\n      <td>0.0</td>\n      <td>0.166667</td>\n      <td>0.666667</td>\n      <td>0.166667</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>104</td>\n      <td>52</td>\n      <td>Deceased</td>\n    </tr>\n  </tbody>\n</table>\n<p>4 rows Ã— 29 columns</p>\n</div>\n```\n:::\n:::\n\n\n",
    "supporting": [
      "06_feat_eng_datetimes_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js\" integrity=\"sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js\" integrity=\"sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}